# -*- coding: utf-8 -*-
"""skeleton_analysis_to_py.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GWlo1AcDAcnaCq66iU_idIg1_LRKWB2x
"""

import cv2
import numpy as np

from skimage.morphology import binary_closing, binary_opening, disk, remove_small_objects
from skimage.morphology import medial_axis
from skimage.util import invert

def generate_bright_mask(img, threshold_percentile=90):
    '''
    Generate a binary mask of the brightest regions in a grayscale image.
    '''
    if img.max() <= 1:
        img = (img * 255).astype(np.uint8)
    else:
        img = img.astype(np.uint8)

    flat_vals = img[img > 0].flatten()
    if len(flat_vals) == 0:
        return np.zeros_like(img, dtype=np.uint8)

    threshold_val = np.percentile(flat_vals, threshold_percentile)

    _, bright_mask = cv2.threshold(img, int(threshold_val), 1, cv2.THRESH_BINARY)
    bright_mask = (bright_mask > 0).astype(np.uint8)

    # Closing the holes
    bright_mask = binary_closing(bright_mask, disk(2))
    bright_mask = binary_opening(bright_mask, disk(2))
    bright_mask = remove_small_objects(bright_mask.astype(bool), min_size=200).astype(np.uint8)

    return bright_mask

def medial_axis_skeleton(binary_image):
    """
    Compute skeleton preserving distance info using medial axis.
    Returns binary skeleton and distance map.
    """

    skel, _ = medial_axis(binary_image, return_distance=True)
    return (skel.astype(np.uint8)) * 255

def combine_axis_skeleton(mask, skeleton):

  _, binary_mask = cv2.threshold(mask, 127, 255, cv2.THRESH_BINARY)

  contours, _ = cv2.findContours(binary_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

  border_image = np.zeros_like(binary_mask)

  cv2.drawContours(border_image, contours, -1, (255, 255, 255), 1)

  result = cv2.bitwise_or(skeleton, border_image)

  return result

def get_length_estimate(img, mask, threshold_percentile=90):

  brg_mask = generate_bright_mask(img, threshold_percentile)
  skeleton_ma = medial_axis_skeleton(brg_mask)
  combined = combine_axis_skeleton(mask, skeleton_ma)

  coords = np.column_stack(np.where(combined > 0))
  length_px = len(coords)

  return round(length_px, 3)

def pixels_to_cm(pixels, reference_cm=10, reference_pixels=255):
  return round(pixels * (reference_cm / reference_pixels), 4)